<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>학급 관계도</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --primary-color: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --background-light: #f9fafb;
            --card-background: #ffffff;
            --border-color: #e5e7eb;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-light);
            color: var(--text-primary);
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 2rem;
            text-align: center;
        }

        /* 버튼 기본 스타일 */
        button {
            position: relative;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: 0.875rem;
            color: white;
            background: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
            overflow: hidden;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        button:active {
            transform: translateY(0);
        }

        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        button:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }

        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            100% {
                transform: scale(100, 100);
                opacity: 0;
            }
        }

        /* 입력 필드 스타일 */
        input[type="text"] {
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: var(--card-background);
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        /* 학생 입력 섹션 */
        .student-input {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--card-background);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
        }

        .student-input input {
            flex: 1;
        }

        .student-input p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* 필터 버튼 */
        .relationship-filter {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin: 2rem 0;
            padding: 1rem;
            background: var(--card-background);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
        }

        .filter-button {
            background: transparent;
            color: var(--text-secondary);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .filter-button:hover {
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary-color);
        }

        .filter-button.active {
            background: var(--primary-color);
            color: white;
        }

        /* 학생 목록 */
        .student-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .student-item {
            position: relative;
            padding: 0.5rem;
            background: var(--card-background);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            transition: all 0.2s ease;
            cursor: pointer;
            overflow: hidden;
            font-size: 0.8rem;
            min-height: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .student-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .student-item span {
            display: block;
            font-weight: 500;
            color: var(--text-primary);
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90%;
        }

        .edit-btn {
            position: absolute;
            top: 0.25rem;
            left: 0.25rem;
            padding: 0.15rem 0.3rem;
            font-size: 0.7rem;
            background: transparent;
            color: var(--text-secondary);
            box-shadow: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .edit-btn:hover {
            color: var(--primary-color);
            background: rgba(99, 102, 241, 0.1);
            transform: none;
            box-shadow: none;
        }

        .delete-btn {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            padding: 0.15rem 0.3rem;
            font-size: 0.7rem;
            background: transparent;
            color: var(--text-secondary);
            box-shadow: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .delete-btn:hover {
            color: var(--danger-color);
            background: rgba(239, 68, 68, 0.1);
            transform: none;
            box-shadow: none;
        }

        .student-item:hover .edit-btn,
        .student-item:hover .delete-btn {
            opacity: 1;
        }

        /* 관계도 맵 */
        #relationship-map-container {
            width: 100%;
            height: 780px;  /* 기본 높이 */
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            margin-bottom: 2rem;
            overflow: hidden;
            transition: height 0.5s ease-in-out; /* 부드러운 높이 전환 효과 */
            max-height: 1560px; /* 최대 2배 크기 제한 */
        }

        /* 노드 스타일 */
        .node circle {
            fill: white;
            stroke: #333;
            stroke-width: 2px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .node text {
            font-size: 10.8px;  /* 12px에서 10% 감소 */
            text-anchor: middle;
            pointer-events: none;
            fill: var(--text-primary);
            transition: all 0.3s ease;
        }

        .node.selected circle {
            stroke: var(--primary-color);
            stroke-width: 4px;
            fill: var(white);
            /*fill: var(--primary-light);*/
        }

        .node.selected text {
            fill: var(--primary-dark);
            font-weight: bold;
        }

        .node.dimmed circle {
            opacity: 0.2;
        }

        .node.dimmed text {
            opacity: 0.2;
        }

        /* 링크 스타일 */
        .link {
            transition: all 0.3s ease;
        }

        .link.dimmed {
            opacity: 0.1;
        }

        .link.highlighted {
            opacity: 1;
            stroke-width: 2.5px;
        }

        /* 주간식 표시 */
        .weekly-form-display {
            background: var(--card-background);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .weekly-form-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .weekly-form-content {
            padding: 0;
        }

        .weekly-form-content h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border-color);
        }

        .form-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.75rem;
            background: #F8FAFC;
            border-radius: var(--radius-md);
            margin-bottom: 0.5rem;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .form-section:hover {
            box-shadow: var(--shadow-sm);
            transform: translateY(-1px);
        }

        .form-section:nth-child(1) { background: #F0FDF4; }
        .form-section:nth-child(2) { background: #FEF2F2; }
        .form-section:nth-child(3) { background: #F0F9FF; }
        .form-section:nth-child(4) { background: #FDF4FF; }
        .form-section:nth-child(5) { background: #ECFDF5; }
        .form-section:nth-child(6) { background: #FFF7ED; }
        .form-section:nth-child(7) { background: #F8FAFC; }
        .form-section:nth-child(8) { background: #F5F5F4; }
        .form-section:nth-child(9) { background: #F0F9FF; }
        .form-section:nth-child(10) { background: #FFFBEB; }

        .form-section h4 {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--primary-color);
            margin: 0;
        }

        .form-section p {
            font-size: 0.875rem;
            color: var(--text-primary);
            line-height: 1.5;
            margin: 0;
        }

        /* 순위 표시 스타일 */
        .ranking-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 0.75rem;
        }

        .ranking-section {
            background: var(--background-light);
            border-radius: var(--radius-md);
            padding: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .ranking-section h4 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            text-align: center;
            padding-bottom: 0.375rem;
            border-bottom: 2px solid var(--border-color);
        }

        .ranking-item {
            display: flex;
            align-items: center;
            padding: 0.2rem 0.4rem;
            border-radius: var(--radius-sm);
            background: white;
            margin-bottom: 0.05rem;
            font-size: 0.825rem;
        }

        .ranking-number {
            font-weight: 600;
            color: var(--primary-color);
            min-width: 18px;
            margin-right: 0.3rem;
        }

        .ranking-name {
            flex: 1;
            font-weight: 500;
            color: var(--text-primary);
        }

        .ranking-count {
            font-weight: 500;
            color: var(--text-secondary);
            padding: 0.1rem 0.4rem;
            background: var(--background-light);
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
        }

        /* 모달 스타일 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-background);
            border-radius: var(--radius-lg);
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            position: relative;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
        }

        .close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .close:hover {
            color: var(--text-primary);
        }

        /* 애니메이션 */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .student-item, .ranking-section, .form-section {
            animation: fadeIn 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{ class_.name }} 학급 관계도</h1>
        
        <div class="student-input">
            <button class="class-select-button" onclick="goToClassSelect()">반 선택</button>
            <input type="text" id="studentName" placeholder="학생 이름 입력" onkeypress="handleKeyPress(event)">
            <button onclick="addStudent()">추가</button>
            <p>학생수: <span id="studentCount">0</span>명</p>
        </div>

        <div class="relationship-filter">
            <button class="filter-button active" data-type="all" onclick="filterRelationships('all')">전체 보기</button>
            <button class="filter-button" data-type="친해" onclick="filterRelationships('친해')">친한 관계</button>
            <button class="filter-button" data-type="보통" onclick="filterRelationships('보통')">보통 관계</button>
            <button class="filter-button" data-type="안친해" onclick="filterRelationships('안친해')">안친한 관계</button>
            <button class="layout-button" onclick="randomizeLayout()">배치 변경</button>
            <button class="reset-button" onclick="resetAllStudents()">학생 초기화</button>
        </div>

        <div class="student-list" id="student-list"></div>
        <div id="relationship-map-container">
        </div>
        <div id="weekly-form-display" class="weekly-form-display">
            <div class="weekly-form-container">
                <div class="weekly-form-content">
                    <h3 id="selected-student-name">주간식 내용</h3>
                    <div id="weekly-form-details">
                        <p>학생을 선택하면 주간식 내용이 표시됩니다.</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="relationship-rankings">
            <h3>관계 순위</h3>
            <div class="ranking-container">
                <div class="ranking-section">
                    <h4>친한 관계 순위</h4>
                    <div id="friendly-ranking" class="ranking-list">
                        <div class="ranking-item">데이터를 불러오는 중...</div>
                    </div>
                </div>
                <div class="ranking-section">
                    <h4>보통 관계 순위</h4>
                    <div id="normal-ranking" class="ranking-list">
                        <div class="ranking-item">데이터를 불러오는 중...</div>
                    </div>
                </div>
                <div class="ranking-section">
                    <h4>안친한 관계 순위</h4>
                    <div id="unfriendly-ranking" class="ranking-list">
                        <div class="ranking-item">데이터를 불러오는 중...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 수정 모달 -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditModal()">&times;</span>
            <h2>학생 이름 수정</h2>
            <input type="text" id="editName" placeholder="새로운 이름">
            <input type="hidden" id="editStudentId">
            <button onclick="updateStudent()">저장</button>
        </div>
    </div>

    <script>
        // 전역 변수
        let students = [];
        let currentClassId = parseInt("{{ class_.id }}");  // Jinja 템플릿 변수를 문자열로 받아서 정수로 변환
        let relationships = [];
        let currentFilter = 'all';  // 관계 필터링용 변수 유지
        const nodeRadius = 22.5;  // 25에서 10% 감소
        const minDistanceRatio = 0.12;  // 노드 간 최소 간격 (화면 크기의 비율)
        const useEmUnits = false;  // true=em 단위 사용, false=화면 비율 기준 사용
        let selectedNodeId = null;
        let nodePositions = {}; // 노드 위치 저장 객체
        let shouldResetPositions = false; // 배치 변경 버튼 클릭 여부 확인 변수

        // API 호출 관리 모듈
        const API = {
            // 학생 관련 API
            student: {
                getAll: async (classId) => {
                    const response = await fetch(`/api/classes/${classId}/students`);
                    if (!response.ok) throw new Error('학생 목록 조회 실패');
                    return response.json();
                },
                
                create: async (data) => {
                    const response = await fetch('/api/students', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    if (!response.ok) throw new Error('학생 추가 실패');
                    return response.json();
                },
                
                update: async (studentId, data) => {
                    const response = await fetch(`/api/students/${studentId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    if (!response.ok) throw new Error('학생 수정 실패');
                    return response.json();
                },
                
                delete: async (studentId) => {
                    const response = await fetch(`/api/students/${studentId}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) throw new Error('학생 삭제 실패');
                    return;
                },
                
                getWeeklyForm: async (studentId) => {
                    try {
                        const response = await fetch(`/api/students/${studentId}/weekly-form`);
                        if (!response.ok) throw new Error('주간식 데이터 조회 실패');
                        
                        const responseText = await response.text();
                        // 빈 응답인 경우 빈 객체 반환
                        if (!responseText.trim()) {
                            return {};
                        }
                        
                        return JSON.parse(responseText);
                    } catch (error) {
                        console.error('주간식 데이터 로드 오류:', error);
                        return {};
                    }
                }
            },

            // 관계 관련 API
            relationship: {
                getAll: async (classId) => {
                    const response = await fetch(`/api/classes/${classId}/relationships`);
                    if (!response.ok) throw new Error('관계 데이터 조회 실패');
                    return response.json();
                },
                
                create: async (data) => {
                    const response = await fetch('/api/relationships', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    if (!response.ok) throw new Error('관계 설정 실패');
                    return response.json();
                }
            }
        };

        // 데이터 관리 모듈
        const DataManager = {
            // 데이터 로드
            async loadData() {
                try {
                    console.log('데이터 로드 시작, class_id:', currentClassId);
                    
                    // 서버에서 학생 데이터 로드
                    students = await API.student.getAll(currentClassId);
                    
                    // 서버에서 관계 데이터 로드
                    relationships = await API.relationship.getAll(currentClassId);
                    
                    // UI 업데이트
                    updateStudentList();
                    updateStudentCount();
                    updateRelationshipMap();
                    calculateRankings();
                } catch (error) {
                    console.error('데이터 로드 중 오류:', error);
                    alert('데이터 로드 중 오류가 발생했습니다.');
                    
                    // 오류 발생 시 초기화
                    students = [];
                    relationships = [];
                    
                    // UI 업데이트
                    updateStudentList();
                    updateStudentCount();
                }
            }
        };

        // 페이지 로드 시 데이터 로드
        window.onload = async function() {
            // 로컬 스토리지에서 노드 위치 로드
            loadNodePositions();
            
            // 데이터 로드
            await DataManager.loadData();
        };

        // 학생 추가 함수 수정
        async function addStudent() {
            const input = document.getElementById('studentName');
            const name = input.value.trim();
            
            if (!name) {
                alert('이름을 입력해주세요.');
                return;
            }

            try {
                // 서버에 학생 추가
                const newStudent = await API.student.create({
                    name: name,
                    class_id: currentClassId
                });
                
                // 데이터 다시 로드
                await DataManager.loadData();
                input.value = '';
            } catch (error) {
                console.error('Error:', error);
                alert('학생 추가 중 오류가 발생했습니다.');
            }
        }

        // 학생 수 업데이트
        function updateStudentCount() {
            document.getElementById('studentCount').textContent = students.length;
        }

        // 학생 목록 업데이트 함수 수정
        function updateStudentList() {
            const studentList = document.getElementById('student-list');
            studentList.innerHTML = '';
            
            students.forEach(student => {
                const studentItem = document.createElement('div');
                studentItem.className = 'student-item';
                studentItem.innerHTML = `
                    <button class="edit-btn" onclick="showEditModal(${student.id}, '${student.name}')">수정</button>
                    <button class="delete-btn" onclick="deleteStudent(${student.id})">삭제</button>
                    <span>${student.name}</span>
                `;
                
                // 학생 카드 클릭 이벤트 추가
                studentItem.addEventListener('click', (e) => {
                    // 수정/삭제 버튼 클릭 시 이벤트 전파 중단
                    if (e.target.className === 'edit-btn' || e.target.className === 'delete-btn') {
                        return;
                    }
                    // 학생의 관계 설정 페이지로 이동
                    const studentId = parseInt(student.id);
                    if (!isNaN(studentId)) {
                        window.location.href = `/relationships/${currentClassId}/student/${studentId}`;
                    } else {
                        console.error('Invalid student ID:', student.id);
                        alert('학생 정보를 불러올 수 없습니다.');
                    }
                });
                
                studentList.appendChild(studentItem);
            });
        }

        // 학생 삭제 함수 수정
        async function deleteStudent(id) {
            if (!confirm('정말 삭제하시겠습니까?')) {
                return;
            }

            try {
                await API.student.delete(id);
                await DataManager.loadData();
            } catch (error) {
                console.error('Error:', error);
                alert('학생 삭제 중 오류가 발생했습니다.');
            }
        }

        // 학생 수정 함수 수정
        async function updateStudent() {
            const id = parseInt(document.getElementById('editStudentId').value);
            const name = document.getElementById('editName').value.trim();
            
            if (!name) {
                alert('이름을 입력해주세요.');
                return;
            }

            try {
                await API.student.update(id, { name: name });
                await DataManager.loadData();
                closeEditModal();
            } catch (error) {
                console.error('Error:', error);
                alert('학생 수정 중 오류가 발생했습니다.');
            }
        }

        // 학생 초기화 함수 수정
        async function resetAllStudents() {
            if (!confirm('모든 학생 정보가 삭제됩니다. 정말 초기화하시겠습니까?\n이 작업은 되돌릴 수 없습니다.')) {
                return;
            }

            try {
                const response = await fetch(`/api/classes/${currentClassId}/reset`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('초기화 중 오류가 발생했습니다.');
                }

                // 데이터 다시 로드
                await DataManager.loadData();
                alert('모든 학생 정보가 초기화되었습니다.');
            } catch (error) {
                console.error('Error:', error);
                alert(error.message);
            }
        }

        // 관계 순위 계산 함수
        function calculateRankings() {
            console.log('관계 순위 계산 시작');
            
            if (!Array.isArray(students) || students.length === 0) {
                console.log('학생 데이터가 없음');
                updateEmptyRankings();
                return;
            }
            
            if (!Array.isArray(relationships) || relationships.length === 0) {
                console.log('관계 데이터가 없음');
                updateEmptyRankings();
                return;
            }
            
            // 각 학생별로 받은 관계 카운트 초기화
            const studentCounts = {};
            students.forEach(student => {
                studentCounts[student.id] = {
                    id: student.id,
                    name: student.name,
                    친해: 0,
                    보통: 0,
                    안친해: 0
                };
            });

            // 관계 카운트 계산 - 각 학생이 다른 학생들로부터 받은 관계
            relationships.forEach(rel => {
                // 유효성 검증
                if (!rel || !rel.student_id || !rel.friend_id || !rel.relationship_type) {
                    console.warn('유효하지 않은 관계 건너뜀:', rel);
                    return;
                }
                
                // 존재하는 학생인지 확인
                if (!studentCounts[rel.friend_id]) {
                    console.warn('존재하지 않는 학생에 대한 관계 건너뜀:', rel);
                    return;
                }
                
                // 관계 유형 확인
                if (!['친해', '보통', '안친해'].includes(rel.relationship_type)) {
                    console.warn('알 수 없는 관계 유형 건너뜀:', rel.relationship_type);
                    return;
                }
                
                // friend_id가 관계를 받는 학생
                studentCounts[rel.friend_id][rel.relationship_type]++;
                console.log(`관계 카운트: ${students.find(s => s.id === rel.friend_id)?.name} - ${rel.relationship_type}: ${studentCounts[rel.friend_id][rel.relationship_type]}`);
            });

            // 디버깅: 카운트 결과 출력
            console.log('관계 카운트 결과:', studentCounts);

            // 각 관계 유형별 순위 계산
            const rankings = {
                친해: [],
                보통: [],
                안친해: []
            };

            // 각 유형별로 순위 생성
            Object.values(studentCounts).forEach(student => {
                ['친해', '보통', '안친해'].forEach(type => {
                    if (student[type] > 0) {
                        rankings[type].push({
                            id: student.id,
                            name: student.name,
                            count: student[type]
                        });
                    }
                });
            });

            // 각 유형별로 정렬 (카운트 내림차순, 같은 경우 이름순)
            ['친해', '보통', '안친해'].forEach(type => {
                rankings[type].sort((a, b) => {
                    if (b.count !== a.count) {
                        return b.count - a.count;
                    }
                    return a.name.localeCompare(b.name);
                });
                console.log(`${type} 관계 순위:`, rankings[type]);
            });

            // UI 업데이트
            updateRankingList('friendly-ranking', rankings['친해'], '친한');
            updateRankingList('normal-ranking', rankings['보통'], '보통');
            updateRankingList('unfriendly-ranking', rankings['안친해'], '안친한');
            
            console.log('관계 순위 계산 완료');
        }

        function updateEmptyRankings() {
            updateRankingList('friendly-ranking', [], '친한');
            updateRankingList('normal-ranking', [], '보통');
            updateRankingList('unfriendly-ranking', [], '안친한');
        }

        // 순위 목록 업데이트 함수
        function updateRankingList(elementId, ranking, typeText) {
            console.log(`${typeText} 관계 순위 업데이트 시작`, elementId);
            
            const container = document.getElementById(elementId);
            if (!container) {
                console.error(`순위 컨테이너를 찾을 수 없음: ${elementId}`);
                return;
            }

            if (!ranking || ranking.length === 0) {
                console.log(`${typeText} 관계 데이터 없음`);
                container.innerHTML = `<div class="ranking-item">아직 ${typeText} 관계로 지정된 학생이 없습니다</div>`;
                return;
            }

            const items = ranking.map((item, index) => `
                <div class="ranking-item" data-student-id="${item.id}">
                    <span class="ranking-number">${index + 1}</span>
                    <span class="ranking-name">${item.name}</span>
                    <span class="ranking-count">${item.count}명</span>
                </div>
            `).join('');

            container.innerHTML = items;
            console.log(`${typeText} 관계 순위 업데이트 완료, 항목 수:`, ranking.length);
        }

        // 순위 모달 관련 함수들
        function showEditModal(studentId, currentName) {
            const modal = document.getElementById('editModal');
            const input = document.getElementById('editName');
            const idInput = document.getElementById('editStudentId');
            
            input.value = currentName;
            idInput.value = studentId;
            
            // 엔터키 이벤트 리스너 추가
            input.onkeypress = function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    updateStudent();
                }
            };
            
            // 모달 표시 방식 수정
            modal.classList.add('active');
            input.focus();
        }

        function closeEditModal() {
            const modal = document.getElementById('editModal');
            modal.classList.remove('active');
        }

        // 엔터 키 이벤트 처리 함수
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                addStudent();
            }
        }

        // 노드 위치 저장 함수
        function saveNodePositions(nodes) {
            const positionsToSave = {};
            
            nodes.forEach(node => {
                positionsToSave[node.id] = {
                    x: node.x,
                    y: node.y
                };
            });
            
            // 현재 위치 업데이트
            nodePositions = positionsToSave;
            
            // 로컬 스토리지에 저장
            localStorage.setItem(`node_positions_class_${currentClassId}`, JSON.stringify(positionsToSave));
            console.log('노드 위치 저장 완료:', Object.keys(positionsToSave).length, '개');
        }

        // 노드 위치 로드 함수
        function loadNodePositions() {
            // 로컬 스토리지에서 저장된 위치 가져오기
            const savedPositions = localStorage.getItem(`node_positions_class_${currentClassId}`);
            
            if (savedPositions) {
                try {
                    nodePositions = JSON.parse(savedPositions);
                    console.log('저장된 노드 위치 로드 완료:', Object.keys(nodePositions).length, '개');
                } catch (e) {
                    console.error('노드 위치 로드 오류:', e);
                    nodePositions = {};
                }
            } else {
                console.log('저장된 노드 위치 없음, 초기화');
                nodePositions = {};
            }
        }

        // 배치 변경 함수 수정
        function randomizeLayout() {
            // 노드 위치 초기화 플래그 설정
            shouldResetPositions = true;
            
            // 관계도 맵 업데이트 (새로운 랜덤 위치 생성)
            updateRelationshipMap();
            
            // 플래그 초기화
            shouldResetPositions = false;
        }

        // 필터링 함수 수정
        function filterRelationships(type) {
            currentFilter = type;
            document.querySelectorAll('.filter-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.filter-button[data-type="${type}"]`).classList.add('active');
            
            // 노드 위치 유지하면서 업데이트
            updateRelationshipMap();
        }

        function updateRelationshipMap() {
            const container = d3.select('#relationship-map-container');
            container.selectAll('*').remove();

            if (students.length === 0) return;
            
            // 기본 크기 설정
            const baseWidth = container.node().getBoundingClientRect().width;
            const baseHeight = 780; // 기본 높이
            
            // 학생 수에 따른 높이 조정
            let adjustedHeight = baseHeight;
            
            // 학생 수가 20명 이상이면 반응형으로 크기 증가
            if (students.length >= 20) {
                // 20명부터 시작해서 10명마다 20% 증가
                const extraRatio = 1 + (Math.floor((students.length - 20) / 10) * 0.2);
                adjustedHeight = Math.min(baseHeight * extraRatio, baseHeight * 2); // 최대 2배까지만 증가
                
                // 컨테이너 높이 조정
                container.style('height', `${adjustedHeight}px`);
                console.log(`학생 수(${students.length})에 따라 맵 높이 조정: ${baseHeight}px → ${adjustedHeight}px`);
            } else {
                // 학생 수가 20명 미만이면 기본 크기로 설정
                container.style('height', `${baseHeight}px`);
            }
            
            const width = baseWidth;
            const height = adjustedHeight;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // 화살표 마커 정의
            const defs = svg.append('defs');
            
            const markerTypes = [
                { type: '친해', color: '#4CAF50', width: 4, height: 4 },
                { type: '보통', color: '#FFC107', width: 4, height: 4 },
                { type: '안친해', color: '#F44336', width: 4, height: 4 }
            ];

            markerTypes.forEach(marker => {
                defs.append('marker')
                    .attr('id', `arrow-${marker.type}`)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', nodeRadius-15)
                    .attr('refY', 0)
                    .attr('markerWidth', marker.width)
                    .attr('markerHeight', marker.height)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .style('fill', marker.color);
            });

            // 필터링된 관계
            const filteredRelationships = relationships.filter(r => {
                if (currentFilter === 'all') return true;
                return r.relationship_type === currentFilter;
            });
            
            // 활성 학생 ID 수집
            const activeStudentIds = new Set();
            filteredRelationships.forEach(r => {
                activeStudentIds.add(r.student_id);
                activeStudentIds.add(r.friend_id);
            });

            const activeStudents = students.filter(s => activeStudentIds.has(s.id));

            if (activeStudents.length === 0) return;

            // 배치 변경이 요청된 경우 위치 초기화
            if (shouldResetPositions) {
                nodePositions = {};
                console.log('노드 위치 초기화 (배치 변경)');
            }

            // 새로운 노드 또는 저장된 위치가 없는 노드 식별
            const needPositions = activeStudents.filter(s => !nodePositions[s.id]);
            
            // 새로운 노드가 있거나 배치 변경이 요청된 경우에만 새 위치 생성
            if (needPositions.length > 0) {
                console.log(`새 위치가 필요한 노드: ${needPositions.length}개`);
                
                // 노드 위치 계산 - 새 노드만 랜덤 위치 생성
                const padding = nodeRadius + 15; // 노드가 경계와 너무 가깝지 않도록 패딩 추가
                
                // 모든 노드 정보 준비 (기존 위치 + 새 위치)
                const nodes = activeStudents.map(student => {
                    const savedPosition = nodePositions[student.id];
                    return {
                        id: student.id,
                        name: student.name,
                        // 저장된 위치가 있으면 사용, 없으면 랜덤 위치 생성
                        x: savedPosition ? savedPosition.x : Math.random() * (width - 2 * padding) + padding,
                        y: savedPosition ? savedPosition.y : Math.random() * (height - 2 * padding) + padding,
                        // 새 노드 표시
                        isNew: !savedPosition
                    };
                });

                // 노드 간 최소 간격 계산
                const minDistance = calculateMinDistance(width, height);
                
                // 노드 간 충돌 감지 및 위치 조정 (최소 간격 확보)
                // 새 노드만 이동하거나, 배치 변경 시 모든 노드 이동
                for (let iter = 0; iter < 30; iter++) { // 최대 30회 반복
                    let moved = false;
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            // 배치 변경이 아니고 두 노드 모두 새 노드가 아니면 건너뜀
                            if (!shouldResetPositions && !nodes[i].isNew && !nodes[j].isNew) continue;
                            
                            const dx = nodes[j].x - nodes[i].x;
                            const dy = nodes[j].y - nodes[i].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < minDistance) {
                                const moveX = (dx / distance) * (minDistance - distance) * 0.5;
                                const moveY = (dy / distance) * (minDistance - distance) * 0.5;
                                
                                // 노드 경계를 넘지 않도록 조정 (패딩 적용)
                                const nodePadding = nodeRadius + 15; // 더 큰 여백 적용
                                const newXi = Math.max(nodePadding, Math.min(width - nodePadding, nodes[i].x - moveX));
                                const newYi = Math.max(nodePadding, Math.min(height - nodePadding, nodes[i].y - moveY));
                                const newXj = Math.max(nodePadding, Math.min(width - nodePadding, nodes[j].x + moveX));
                                const newYj = Math.max(nodePadding, Math.min(height - nodePadding, nodes[j].y + moveY));
                                
                                if (nodes[i].x !== newXi || nodes[i].y !== newYi || 
                                    nodes[j].x !== newXj || nodes[j].y !== newYj) {
                                    moved = true;
                                }
                                
                                nodes[i].x = newXi;
                                nodes[i].y = newYi;
                                nodes[j].x = newXj;
                                nodes[j].y = newYj;
                            }
                        }
                    }
                    if (!moved) break; // 더 이상 움직임이 없으면 종료
                }
                
                // 새 위치 저장
                saveNodePositions(nodes);
            } else {
                console.log('모든 노드의 위치가 이미 저장되어 있음');
            }
            
            // 저장된 위치 사용해서 노드 생성
            const nodes = activeStudents.map(student => {
                const position = nodePositions[student.id] || { 
                    x: width / 2, 
                    y: height / 2 
                };
                
                return {
                    id: student.id,
                    name: student.name,
                    x: position.x,
                    y: position.y
                };
            });

            // 링크 데이터 생성
            const links = filteredRelationships.map(rel => ({
                source: nodes.find(n => n.id === rel.student_id),
                target: nodes.find(n => n.id === rel.friend_id),
                type: rel.relationship_type,
                student_id: rel.student_id,
                friend_id: rel.friend_id
            })).filter(link => link.source && link.target);

            // 링크 그리기
            const link = svg.selectAll('.link')
                .data(links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('data-source', d => d.source.id)
                .attr('data-target', d => d.target.id)
                .attr('marker-end', d => `url(#arrow-${d.type})`)
                .style('stroke', d => {
                    switch (d.type) {
                        case '친해': return '#4CAF50';
                        case '보통': return '#FFC107';
                        case '안친해': return '#F44336';
                        default: return '#999';
                    }
                })
                .style('stroke-width', 2)
                .style('fill', 'none');

            // 노드 클릭 이벤트 핸들러
            function handleNodeClick(event, d) {
                // 이벤트 전파 중단
                event.stopPropagation();
                
                console.log("노드 클릭됨:", d.name, "ID:", d.id, "현재 선택된 ID:", selectedNodeId);
                
                // 같은 노드를 다시 클릭한 경우 (토글 처리)
                if (selectedNodeId === d.id) {
                    console.log("같은 노드 다시 클릭 - 선택 해제");
                    
                    // 모든 노드와 링크 강조 해제
                    d3.selectAll('.node').classed('selected', false).classed('dimmed', false);
                    d3.selectAll('.link').classed('dimmed', false).classed('highlighted', false);
                    
                    // 선택 상태 초기화
                    selectedNodeId = null;
                } else {
                    console.log("새로운 노드 선택 - 강조 적용");
                    
                    // 모든 노드와 링크를 초기화
                    d3.selectAll('.node').classed('selected', false).classed('dimmed', true);
                    d3.selectAll('.link').classed('dimmed', true).classed('highlighted', false);
                    
                    // 선택된 노드 강조
                    d3.select(this)
                        .classed('selected', true)
                        .classed('dimmed', false);
                    
                    // 연결된 노드와 링크 강조
                    links.forEach(linkData => {
                        if (linkData.source.id === d.id || linkData.target.id === d.id) {
                            // 연결된 링크 강조
                            d3.selectAll(`path.link[data-source="${linkData.source.id}"][data-target="${linkData.target.id}"]`)
                                .classed('dimmed', false)
                                .classed('highlighted', true);
                            
                            // 연결된 노드 강조
                            const connectedId = linkData.source.id === d.id ? linkData.target.id : linkData.source.id;
                            d3.selectAll('.node').filter(function() {
                                return d3.select(this).datum().id === connectedId;
                            }).classed('dimmed', false);
                        }
                    });
                    
                    // 현재 선택된 노드 ID 업데이트
                    selectedNodeId = d.id;
                }
                
                // 주간식 데이터 로드 (항상 실행)
                loadWeeklyForm(d.id);
            }

            // SVG 배경 클릭 시 모든 강조 효과 제거
            svg.on('click', () => {
                d3.selectAll('.node').classed('selected', false)
                    .classed('dimmed', false);
                
                d3.selectAll('.link').classed('dimmed', false)
                    .classed('highlighted', false);
                
                // 선택 상태 초기화
                selectedNodeId = null;
            });

            // 노드 그룹 생성 - 드래그 기능 추가
            const node = svg.selectAll('.node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .on('click', handleNodeClick);

            // 노드 원 그리기 - 스타일 직접 지정 제거, CSS로 통일
            node.append('circle')
                .attr('r', nodeRadius);

            // 노드 텍스트 그리기 - 스타일 직접 지정 제거, CSS로 통일
            node.append('text')
                .attr('dy', '.35em')
                .text(d => d.name);

            // 링크 경로 업데이트 함수 - 드래그 없이 정적 표시만 필요
            function updateLinks() {
                link.attr('d', d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const angle = Math.atan2(dy, dx);
                    
                    // 시작점과 끝점 계산
                    const startX = d.source.x + nodeRadius * Math.cos(angle);
                    const startY = d.source.y + nodeRadius * Math.sin(angle);
                    const endX = d.target.x - nodeRadius * Math.cos(angle);
                    const endY = d.target.y - nodeRadius * Math.sin(angle);
                    
                    // 곡률 계산 (소스와 타겟 ID 기반 고정값)
                    const curvature = (Math.sin(d.source.id * d.target.id) * 0.0117) + 0.00585;
                    
                    // 제어점 계산
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    const offsetX = -dy * curvature;
                    const offsetY = dx * curvature;
                    
                    // 2차 베지어 곡선으로 경로 생성
                    return `M${startX},${startY} Q${midX + offsetX},${midY + offsetY} ${endX},${endY}`;
                });
            }

            // 초기 링크 업데이트
            updateLinks();
        }

        // 노드 간 최소 간격 계산 함수
        function calculateMinDistance(width, height) {
            if (useEmUnits) {
                // em 단위 기준 (1em = 16px로 가정)
                const emToPixel = 16;
                const distanceInEm = 6;  // 6em 간격
                return distanceInEm * emToPixel;
            } else {
                // 화면 크기 비율 기준
                return Math.min(width, height) * minDistanceRatio;
            }
        }

        // 주간식 데이터 로드 함수
        function loadWeeklyForm(studentId) {
            const weeklyFormDetails = document.getElementById('weekly-form-details');
            const selectedStudentName = document.getElementById('selected-student-name');
            
            // 현재 선택된 학생 찾기
            const selectedStudent = students.find(s => s.id === studentId);
            
            // 학생을 선택하지 않았을 때
            if (!selectedStudent) {
                selectedStudentName.textContent = "주간식 내용";
                weeklyFormDetails.innerHTML = '<p>학생을 선택하면 주간식 내용이 표시됩니다.</p>';
                return;
            }
            
            // 학생을 선택한 경우
            selectedStudentName.textContent = `${selectedStudent.name}의 주간식 내용`;
            weeklyFormDetails.innerHTML = '<p>데이터를 불러오는 중...</p>';
            
            // API를 통해 주간식 데이터 가져오기
            API.student.getWeeklyForm(studentId)
                .then(weeklyForm => {
                    console.log('주간식 데이터 로드 완료:', weeklyForm);
                    
                    // 추가 질문 항목 검색 및 표시
                    const additionalQuestionKeys = Object.keys(weeklyForm || {})
                        .filter(key => key.startsWith('additional_question_'));
                    
                    // 추가 질문이 있는 경우 표시
                    if (additionalQuestionKeys.length > 0) {
                        // 질문 답변 순서대로 정렬
                        additionalQuestionKeys.sort((a, b) => {
                            const numA = parseInt(a.split('_').pop());
                            const numB = parseInt(b.split('_').pop());
                            return numA - numB;
                        });
                        
                        // HTML 생성
                        let formHtml = '';
                        
                        additionalQuestionKeys.forEach(key => {
                            // 질문과 답변 가져오기
                            const questionData = weeklyForm[key] || {};
                            
                            // 질문 내용과 답변 내용 가져오기
                            const question = questionData.question || '';
                            const answer = questionData.answer || '입력된 내용이 없습니다.';
                            
                            // 질문이 있는 경우에만 표시
                            if (question) {
                                formHtml += `
                                    <div class="form-section">
                                        <h4>${question}</h4>
                                        <p>${answer}</p>
                                    </div>
                                `;
                            }
                        });
                        
                        // HTML 업데이트
                        weeklyFormDetails.innerHTML = formHtml;
                    } else {
                        weeklyFormDetails.innerHTML = '<p>입력된 주간식 내용이 없습니다.</p>';
                    }
                })
                .catch(error => {
                    console.error('주간식 데이터 로드 중 오류:', error);
                    weeklyFormDetails.innerHTML = '<p>주간식 데이터를 불러오는데 실패했습니다.</p>';
                });
        }

        // 반 선택 페이지로 이동
        function goToClassSelect() {
            window.location.href = '/classes';
        }
    </script>
</body>
</html> 